<pre>
  NEP: 12
  Title: SeraphID
  Authors: Kasimir Blaser, <Kasimir.Blaser@swisscom.com>,
           Luigi Riva <Luigi.Riva@swisscom.com>,
           Piotr Janus <Piotr.Janus@swisscom.com>
  Type: Standard
  Status: Draft
  Created: 2019-01-XYZ
</pre>

== Abstract ==

The SeraphID is a concrete implementation of a self sovereign identity. 
It uses the [NEO-DID] as identifier for individuals, companies, groups, machines, IoT devices and many more. 

An individual may have and control multiple virtual identities (DIDs). Based on the context an individual will
choose a DID to interact with a system if there is an authentication or authorization required.

An issuer can assign claims to a DID. The Holder of the DID can then later on use this claim to proof certain 
conditions if required. 

On a higher level DIDs and claims can be used (issued, hold and verified) off-chain and on-chain.

== Motivation ==

TBD...

==Rationale==

TBD...

== Specification ==
The SeraphID is defined by two Smart Contract interfaces for: 
* Claim Issuers: defines mandatory methods to:
** structure claims - define valid schemas and properties (key names) for claims
** issue claims - define methods to issue and validate claims
* Trust Anchors: defines mandatory methods to organize and group issuers into networks of trusted parties.

=== Claim structure ===
Every claim issued in NEO SeraphID consists of the following information:
* issuer - the address of claim issuer
* holder - the address of claim holder
* schema - name of the issuer's claim schema the claim belongs to
* properties - a map of multiple claim properties and their values
* validFrom - (optional) date from which the claim is valid - in JSON date time format based upon a simplification of the [ISO-8601] extended format, which is YYYY-MM-DDTHH:mm:ss.sssZ
* validTo - (optional) date to which the claim is valid - in JSON date time format based upon a simplification of the [ISO-8601] extended format, which is YYYY-MM-DDTHH:mm:ss.sssZ
* signature - issuer signature of the claim.
* hash - a unique hash of the claim generated by smart contract.

<pre>
[Serializable]
public struct Claim
{
    public byte[] issuer;
    public byte[] holder;
    public string schema;
    public Map<string, byte[]> properties;
    public string validFrom;
    public string validTo;
    public byte[] signature;
    public string hash;
}
</pre>

Based on this definition, claims are defined as a set of property-value information with optional validity period that can be grouped together within a claim's schema. The claims can be issued with all schema properties or a subset of them signed together. Claim's properties signed separately, can also be validated separately without disclosing information about the other attributes in the schema. On the other hand issuing all schema properties as a single signed claim, lowers the number of smart contract calls.

=== Claim Issuer interface ===

==== Schema methods ====

===== IsValidSchema =====
<pre>
public static bool IsValidSchema(string schema)
</pre>

This method returns a boolean True/False if a given Scheme exists and is supported by the Smart Contract. 

In addition the schema Smart Contract may have additional methods to add or remove <code>schemas</code>
This is not part of this specification. Keep in mind that in case a <code>schema</code> is removed all claims which are based on this schema will be immediately invalid. 

===== IsValidSchemaProperty =====
<pre>
public static bool IsValidSchemaProperty(string schema, string property)
</pre>

This method returns a boolean True/False if a given property in the scheme exists. 

In addition the schema Smart Contract may have additional methods to add or remove schema <code>properties</code>. 
This is not part of this specification. Keep in mind that in case a <code>property</code> of a schema is removed all claims which are based on this property will be immediately invalid. 

===== GetSupportedSchemas =====
<pre>
public static string[] GetSupportedSchemas()
</pre>

This method returns an array of schema names supported by the Smart Contract.

===== GetSchemaProperties =====
<pre>
public static string[] GetSchemaProperties(string schema)
</pre>

This method returns an array of properties defined in the given schema.

==== Claim methods ====

===== IssueClaim =====

<pre>
public static Claim IssueClaim(Claim newClaim)
</pre>

With this method an issuer can issue a claim to the given holder and inject the hash of the claim into the smart contract. 
It is up to the contract developer/owner to decide who can issue claims using it. Both options have their pros and cons. 
Technically it's also possible that a claim holder can issue his claim to make it public and also on-chain provable.
Claims injected and stored in smart contract will be publicly visible, claims that are just returned by the smart contract and stored as a hash can be stored off-chain by the holder and not disclosed publicly.

The method returns a Claim object with all claim's properties and claim's hash by which it is identified in the smart contract.
Hash calculation method is open for developer's implementation, however it shall always be unique for each issued claim within the contract.

===== RevokeClaim =====

<pre>
public static bool RevokeClaim(string hash)
</pre>

This method can be used by the claim issuer to revoke previously issued claim identified by the given hash.
It is up to the Smart Contract developer/owner to decide if the claim can be revoked or not.
The method returns boolean <code>True</code> if the claim was successfully revoked and <code>False</code> otherwise.
 
===== IsValidHash =====

<pre>
public static bool IsValidHash(string hash)
</pre>

With the method <code>IsValidHash</code> the hash of a claim can be verified. 
This only tells that the hash matches an existing claim which is still valid, but does not return any claim property nor it validates claim signature.

===== IsValid =====

<pre>
public static bool IsValid(Claim claim)
</pre>

The method <code>IsValid</code> checks if the claim has not been revoked and then validates it's signature to make sure the claim was not tampered with. It returns boolean <code>True</code> when the claim is still valid and legitimate or <code>False</code> otherwise. It is up to the caller then to validate separete property values of the claim if they match their specific requirements.

=== Trust Anchor interface ===
The Trust Anchor within SeraphID is an optional entity that can help claim verifiers validate claims and build networks of trust.
A Trust Anchor is represented as a smart contract defined by the following interface:

==== IsTrusted ====
<pre>
public static bool IsTrusted(byte[] issuer)
</pre>

The <code>IsTrusted</code> method checks if the issuer identified by the given address is trusted within the trust network of this anchor.
It returns boolean <code>True</code> if the issuer is trusted or <code>False</code> otherwise.
In case the issuer is not directly trusted by this anchor, the trust anchor can relay the verification of the issuer to other trust anchors registered in his smart contract.

==== GetTrustedIssuers ====
<pre>
public static byte[][] GetTrustedIssuers()
</pre>

The <code>GetTrustedIssuers</code> method returns an array of <code>Claim Issuers</code> addresses trusted by this anchor.
It is up to the smart contract developer/owner to define mechanisms of adding and removing claim issuers to their network of trust.

==== GetTrustedAnchors ====
<pre>
public static byte[][] GetTrustedAnchors()
</pre>

The <code>GetTrustedAnchors</code> method returns an array of other <code>Trust Anchors</code> smart contract addresses trusted by this anchor.
It is up to the smart contract developer/owner to define mechanisms of adding and removing other trust anchors within their network of trust.

==== Name ====
<pre>
public static string Name()
</pre>

This method returns the official name of the Trust Anchor (smart contract owner).
